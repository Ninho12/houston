---
name: useCallbackObservable
route: /hooks/useCallbackObservable
menu: eduzz/houston-hooks
submenu: Hooks
---

import { interval } from 'rxjs';
import { take } from 'rxjs/operators';

import Button from '@eduzz/houston-ui/Button';
import Typography from '@eduzz/houston-ui/Typography';

import { Playground } from 'docz';

import useCallbackObservable from '.';

# useCallbackObservable

É o mesmo principio do **useObservable**, mas a primeira posição do array é uma function e o observable só é chamada quando
esse função é chamada.

## Como usar

```tsx
const [callback, value, error, completed, loading] = useCallbackObservable(
  (params: any) => userService.get(params),
  []
);

return (
  <div>
    {loading ? 'Carregando' : ''}
    {value}
    <Button onClick={onClick} variant='text'>
      Vai
    </Button>
  </div>
);
```

<Playground>
  {() => {
    const [onClick, value, error] = useCallbackObservable(() => interval(1000).pipe(take(10)), []);
    return (
      <div>
        <Typography>Value: {value || 'Nada'}</Typography>
        <Button onClick={onClick} variant='text'>
          Vai
        </Button>
      </div>
    );
  }}
</Playground>

## Cuidados

- **Erros** ocorridos serão automaticamentes logados (não tratados) se as o **onUnhandledError** no **setHoustonHooksConfig**
  for setado, mas se utilizar o operador catchError esse erro não será logado pois foi previamente tratado,
  nesse caso o log deve ser feito manualmente.
- O valor inicial será **undefined**, lembre-se de tratar isso quando estiver usando.

## Parâmetros e Retorno

```ts
/**
 * Create a memoized callback that uses an observable and unsubscribe automatically if component unmount
 * @param observableGenerator Function to return a observable
 * @param deps List of deps
 * @returns [callbackFunction, observableValue, error, complete, loading]
 */
export default function useCallbackObservable<T>(
  observableGenerator: (...args: any[]) => Observable<T>,
  deps: React.DependencyList
): [() => void, T, any, boolean, boolean];
```

{"version":3,"sources":["webpack:///../packages/hooks/useObservablePaginated/index.mdx"],"names":["_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","isMDXComponent"],"mappings":"qRAQaA,EAAe,Q,iOAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,IAFDC,EAEC,EAFDA,WACGC,EACF,iBACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAG5E,kBACE,GAAM,0BADR,0BAGA,kKAEA,kBACE,GAAM,aADR,aAGA,uBAAK,oBAAMC,WAAW,MAClB,UAAa,gBADZ,6SAWL,kBACE,GAAM,YADR,YAGA,sBACE,kBAAIA,WAAW,MAAK,sBAAQA,WAAW,MAAnB,SAApB,oEAAmI,sBAAQA,WAAW,MAAnB,oBAAnI,OAAgM,sBAAQA,WAAW,MAAnB,yBAAhM,8JAIF,kBACE,GAAM,wBADR,wBAGA,uBAAK,oBAAMA,WAAW,MAClB,UAAa,eADZ,mzD,+NAgCTJ,EAAWK,gBAAiB","file":"component---packages-hooks-use-observable-paginated-index-mdx-bf479a465763e86ab11a.js","sourcesContent":["import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/github/workspace/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n    <h1 {...{\n      \"id\": \"useobservablepaginated\"\n    }}>{`useObservablePaginated`}</h1>\n    <p>{`Hook para facilitar o uso de um observable paginado, dá Subscribe e retorna\no resultado junto com funções de manipulação dos parametros.`}</p>\n    <h2 {...{\n      \"id\": \"como-usar\"\n    }}>{`Como usar`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`const { params, handleChangePage, handleChangePerPage, handleSort, result, total, isLoading } = useObservablePaginated(\n  {\n    initialParams: { page: 1, perPage: 5 }, // optional\n    infinityScroll: false, // optional\n    onChangeParams: params => salesService.list(params)\n  },\n  []\n);\n`}</code></pre>\n    <h2 {...{\n      \"id\": \"cuidados\"\n    }}>{`Cuidados`}</h2>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Erros`}</strong>{` ocorridos serão automaticamentes logados (não tratados) se as o `}<strong parentName=\"li\">{`onUnhandledError`}</strong>{` no `}<strong parentName=\"li\">{`setHoustonHooksConfig`}</strong>{`\nfor setado, mas se utilizar o operador catchError esse erro não será logado pois foi previamente tratado,\nnesse caso o log deve ser feito manualmente.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"parâmetros-e-retorno\"\n    }}>{`Parâmetros e Retorno`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`/**\n * @param options \\`IUsePaginatedOptions\\`: {\n *  initialParams: Estado inicial dos paramêtros\n *  infinityScroll: Se os resultados devem ser mergeado, criando uma lista infinita.\n *  onChangeParams: Função que recebe os paramêtros e retorna um Observable\n * }\n * @param deps React deps\n * @returns \\`IUsePaginatedObservable\\`: {\n *  params: P / Json com os parametros\n *  initialParams: Partial<P> / Json com os parametros iniciais, útil para um reset de filtros\n *  isLoading: boolean; / Se está carregando ou não\n *  isLoadingMore: boolean; / Se está carregando mais ou não, útil para o infinityScroll\n *  total: number; / Número total de linhas retornadas, apenas a requisição da pagina inicial é necessário retornar o total, as outras paginas podem retonar null\n *  result: R[]; / Array com o resultado\n *  hasMore: boolean; / Se existe mais para ser carregado, calculado com base do total, útil para o infinityScroll\n *  error: any; / Error, se aconteceu algum\n *  retry: () => void; / Função de retry\n *  updateInitialParams: React.Dispatch<React.SetStateAction<P>>; / Útil para alterar o reset de um filtro\n *  mergeParams: (params: PaginationMergeParams<P>) => void; / Função para atualizar os paramentros pode ser o valor em sí o uma função que recebe o valor atual\n *  handleChangePage: (page: number) => void; / Função de atalho para o mergeParams({ page: 1})\n *  handleChangePerPage: (perPage: number) => void; / Função de atalho para o mergeParams({ perPge: 1})\n *  handleSort: (sort: IPaginationParams['sort']) => void; / Função de atalho para o mergeParams({ sort: { field: 'name', direction: 'asc' }  })\n * }\n */\nexport default function useObservablePaginated<P extends IPaginationParams, R>(options: IUsePaginatedOptions<P, R>, , deps: React.DependencyList): IUsePaginatedObservable<P, R>\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}
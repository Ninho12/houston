{"version":3,"sources":["webpack:///../packages/hooks/node_modules/rxjs/dist/esm5/internal/observable/interval.js","webpack:///../packages/hooks/useCallbackObservable/index.mdx"],"names":["interval","period","scheduler","_frontmatter","layoutProps","MDXLayout","DefaultLayout","MDXContent","components","props","mdxType","parentName","__position","__code","__scope","take","Button","Typography","Playground","useCallbackObservable","pipe","onClick","value","variant","isMDXComponent"],"mappings":"8FAAA,8DAEO,SAASA,EAASC,EAAQC,GAa/B,YAZe,IAAXD,IACFA,EAAS,QAGO,IAAdC,IACFA,EAAY,KAGVD,EAAS,IACXA,EAAS,GAGJ,YAAMA,EAAQA,EAAQC,K,sQCDlBC,G,UAAe,S,gOAC5B,IAAMC,EAAc,CAClBD,gBAEIE,EAAYC,IACH,SAASC,EAAT,GAGZ,MAFDC,EAEC,EAFDA,WACGC,EACF,8BACD,OAAO,YAACJ,EAAD,eAAeD,EAAiBK,EAAhC,CAAuCD,WAAYA,EAAYE,QAAQ,cAO5E,kBACE,GAAM,yBADR,yBAGA,+CAA8B,sBAAQC,WAAW,KAAnB,iBAA9B,+GAEA,kBACE,GAAM,aADR,aAGA,uBAAK,oBAAMA,WAAW,MAClB,UAAa,gBADZ,qSAiBL,YAAC,IAAD,CAAYC,WAAY,EAAGC,OAAQ,iTAAoTC,SAAO,GAC5VL,QACAH,kBACAN,aACAe,SACAC,WACAC,eACAC,eACAC,2BAR4V,gBAS5Vb,IAT4V,EAU5VH,eAV4V,GAW3VO,QAAQ,eACZ,WACK,MAAgCS,aAAsB,kBAAMnB,YAAS,KAAMoB,KAAKL,YAAK,OAAM,IAApFM,EAAP,KAAgBC,EAAhB,UACA,OAAO,uBACP,YAAC,IAAD,CAAYZ,QAAQ,cAApB,UAAyCY,GAAS,QAClD,YAAC,IAAD,CAAQD,QAASA,EAASE,QAAQ,OAAOb,QAAQ,UAAjD,WAMJ,kBACE,GAAM,YADR,YAGA,sBACE,kBAAIC,WAAW,MAAK,sBAAQA,WAAW,MAAnB,SAApB,oEAAmI,sBAAQA,WAAW,MAAnB,oBAAnI,OAAgM,sBAAQA,WAAW,MAAnB,yBAAhM,6JAGA,kBAAIA,WAAW,MAAf,wBAA6C,sBAAQA,WAAW,MAAnB,aAA7C,sDAEF,kBACE,GAAM,wBADR,wBAGA,uBAAK,oBAAMA,WAAW,MAClB,UAAa,eADZ,8d,8NAiBTJ,EAAWiB,gBAAiB","file":"component---packages-hooks-use-callback-observable-index-mdx-71a17023c6a3430a01e8.js","sourcesContent":["import { asyncScheduler } from '../scheduler/async';\nimport { timer } from './timer';\nexport function interval(period, scheduler) {\n  if (period === void 0) {\n    period = 0;\n  }\n\n  if (scheduler === void 0) {\n    scheduler = asyncScheduler;\n  }\n\n  if (period < 0) {\n    period = 0;\n  }\n\n  return timer(period, period, scheduler);\n}","import * as React from 'react'\n  /* @jsx mdx */\nimport { mdx } from '@mdx-js/react';\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\n\nimport DefaultLayout from \"/github/workspace/node_modules/gatsby-theme-docz/src/base/Layout.js\";\nimport { interval } from 'rxjs';\nimport { take } from 'rxjs/operators';\nimport Button from '@eduzz/houston-ui/Button';\nimport Typography from '@eduzz/houston-ui/Typography';\nimport { Playground } from 'docz';\nimport useCallbackObservable from '.';\nexport const _frontmatter = {};\nconst layoutProps = {\n  _frontmatter\n};\nconst MDXLayout = DefaultLayout;\nexport default function MDXContent({\n  components,\n  ...props\n}) {\n  return <MDXLayout {...layoutProps} {...props} components={components} mdxType=\"MDXLayout\">\n\n\n\n\n\n\n    <h1 {...{\n      \"id\": \"usecallbackobservable\"\n    }}>{`useCallbackObservable`}</h1>\n    <p>{`É o mesmo principio do `}<strong parentName=\"p\">{`useObservable`}</strong>{`, mas a primeira posição do array é uma function e o observable só é chamada quando\nesse função é chamada.`}</p>\n    <h2 {...{\n      \"id\": \"como-usar\"\n    }}>{`Como usar`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-tsx\"\n      }}>{`const [callback, value, error, completed, loading] = useCallbackObservable(\n  (params: any) => userService.get(params),\n  []\n);\n\nreturn (\n  <div>\n    {loading ? 'Carregando' : ''}\n    {value}\n    <Button onClick={onClick} variant='text'>\n      Vai\n    </Button>\n  </div>\n);\n`}</code></pre>\n    <Playground __position={0} __code={'() => {\\n  const [onClick, value, error] = useCallbackObservable(\\n    () => interval(1000).pipe(take(10)),\\n    [],\\n  )\\n  return (\\n    <div>\\n      <Typography>Value: {value || \\'Nada\\'}</Typography>\\n      <Button onClick={onClick} variant=\\\"text\\\">\\n        Vai\\n      </Button>\\n    </div>\\n  )\\n}'} __scope={{\n      props,\n      DefaultLayout,\n      interval,\n      take,\n      Button,\n      Typography,\n      Playground,\n      useCallbackObservable,\n      DefaultLayout,\n      _frontmatter\n    }} mdxType=\"Playground\">\n  {() => {\n        const [onClick, value, error] = useCallbackObservable(() => interval(1000).pipe(take(10)), []);\n        return <div>\n        <Typography mdxType=\"Typography\">Value: {value || 'Nada'}</Typography>\n        <Button onClick={onClick} variant='text' mdxType=\"Button\">\n          Vai\n        </Button>\n      </div>;\n      }}\n    </Playground>\n    <h2 {...{\n      \"id\": \"cuidados\"\n    }}>{`Cuidados`}</h2>\n    <ul>\n      <li parentName=\"ul\"><strong parentName=\"li\">{`Erros`}</strong>{` ocorridos serão automaticamentes logados (não tratados) se as o `}<strong parentName=\"li\">{`onUnhandledError`}</strong>{` no `}<strong parentName=\"li\">{`setHoustonHooksConfig`}</strong>{`\nfor setado, mas se utilizar o operador catchError esse erro não será logado pois foi previamente tratado,\nnesse caso o log deve ser feito manualmente.`}</li>\n      <li parentName=\"ul\">{`O valor inicial será `}<strong parentName=\"li\">{`undefined`}</strong>{`, lembre-se de tratar isso quando estiver usando.`}</li>\n    </ul>\n    <h2 {...{\n      \"id\": \"parâmetros-e-retorno\"\n    }}>{`Parâmetros e Retorno`}</h2>\n    <pre><code parentName=\"pre\" {...{\n        \"className\": \"language-ts\"\n      }}>{`/**\n * Create a memoized callback that uses an observable and unsubscribe automatically if component unmount\n * @param observableGenerator Function to return a observable\n * @param deps List of deps\n * @returns [callbackFunction, observableValue, error, complete, loading]\n */\nexport default function useCallbackObservable<T>(\n  observableGenerator: (...args: any[]) => Observable<T>,\n  deps: React.DependencyList\n): [() => void, T, any, boolean, boolean];\n`}</code></pre>\n\n    </MDXLayout>;\n}\n;\nMDXContent.isMDXComponent = true;\n      "],"sourceRoot":""}